# ========================================================================
# Parser Name        : Microsoft_Email_Parser.conf
# Product            : Microsoft Security / Email
# Author             : rukky.soneye@foresite.com
# Updated By         : Mayank Mishra (Newbieget)
# Last Updated       : 2025-10-30
# Notes              : Enhanced version â€“ added SenderIP, SpamConfidenceLevel, and PolicyAction
# ========================================================================

filter {

  # -----------------------------
  # 0) SAFE PRE-INIT
  # -----------------------------
  mutate {
    replace => {
      "sha_candidate" => ""
      "category"      => ""
      "operationName" => "%{operationName}"
    }
  }

  # -----------------------------
  # 1) EXTRACT JSON
  # -----------------------------
  json {
    source         => "message"
    array_function => "split_columns"
    on_error       => "zerror.json_data_invalid"
  }

  # Normalize product_event_type early (prefer properties.OperationName)
  if [properties][OperationName] != "" {
    mutate { replace => { "operationName" => "%{[properties][OperationName]}" } }
  }

  # -----------------------------
  # 2) HANDLE ONLY EMAIL "Publish" EVENTS
  # -----------------------------
  if [operationName] == "Publish" {

    # ---- UDM: metadata.product_event_type
    if [operationName] != "" {
      mutate {
        replace  => { "event.metadata.product_event_type" => "%{operationName}" }
        on_error => "zerror.REPLACE_product_event_type"
      }
    }

    # ---- UDM: target.administrative_domain
    if [properties][RecipientDomain] != "" {
      mutate {
        replace  => { "event.target.administrative_domain" => "%{[properties][RecipientDomain]}" }
        on_error => "zerror.REPLACE_target_administrative_domain"
      }
    }

    # ---- UDM: security_result (prefer free-text in category_details)
    if [properties][ThreatClassification] != "" {
      mutate {
        replace  => { "event.security_result.category_details" => "%{[properties][ThreatClassification]}" }
        on_error => "zerror.REPLACE_threat_category_details"
      }
    }

    # -----------------------------
    # 2a) EMAIL RECIPIENTS (TO / CC)
    # -----------------------------
    mutate { add_fields => { "to_list" => [] "cc_list" => [] } }

    if [properties][To] != "" {
      for item in properties.To {
        grok {
          match    => { "item" : [ "%{EMAILADDRESS:__to_email}" ] }
          on_error => "ignore_to_string"
        }
        if [__to_email] != "" {
          mutate { append => { "to_list" => "%{__to_email}" } }
          mutate { remove_field => ["__to_email"] }
        } else {
          grok {
            match    => { "[item][Address]" : [ "%{EMAILADDRESS:__to_email2}" ] }
            on_error => "ignore_to_obj"
          }
          if [__to_email2] != "" {
            mutate { append => { "to_list" => "%{__to_email2}" } }
            mutate { remove_field => ["__to_email2"] }
          }
        }
      }
    }

    if [properties][Cc] != "" {
      for item in properties.Cc {
        grok {
          match    => { "item" : [ "%{EMAILADDRESS:__cc_email}" ] }
          on_error => "ignore_cc_string"
        }
        if [__cc_email] != "" {
          mutate { append => { "cc_list" => "%{__cc_email}" } }
          mutate { remove_field => ["__cc_email"] }
        } else {
          grok {
            match    => { "[item][Address]" : [ "%{EMAILADDRESS:__cc_email2}" ] }
            on_error => "ignore_cc_obj"
          }
          if [__cc_email2] != "" {
            mutate { append => { "cc_list" => "%{__cc_email2}" } }
            mutate { remove_field => ["__cc_email2"] }
          }
        }
      }
    }

    if [to_list] {
      mutate { replace => { "event.network.email.to" => "%{to_list}" } }
    }
    if [cc_list] {
      mutate { replace => { "event.network.email.cc" => "%{cc_list}" } }
    }

    # -----------------------------
    # 2b) SHA256 with fallbacks
    # -----------------------------
    mutate { replace => { "sha_candidate" => "" } }

    if [properties][SHA256] != "" {
      mutate { replace => { "sha_candidate" => "%{[properties][SHA256]}" } on_error => "zerror.sha_try1_missing" }
    }
    if [sha_candidate] == "" and [properties][FileSha256] != "" {
      mutate { replace => { "sha_candidate" => "%{[properties][FileSha256]}" } on_error => "zerror.sha_try2_missing" }
    }
    if [sha_candidate] == "" and [properties][AttachmentSha256] != "" {
      mutate { replace => { "sha_candidate" => "%{[properties][AttachmentSha256]}" } on_error => "zerror.sha_try3_missing" }
    }
    if [sha_candidate] == "" and [properties]["FileSha 256"] != "" {
      mutate { replace => { "sha_candidate" => "%{[properties][FileSha 256]}" } on_error => "zerror.sha_try4_missing" }
    }

    if [sha_candidate] != "" {
      mutate {
        replace  => { "event.target.file.sha256" => "%{sha_candidate}" }
        on_error => "zerror.REPLACE_target_file_sha256"
      }
    }

    # -----------------------------
    # 2c) ADDITIONAL NEW FIELDS (Client Requirement)
    # -----------------------------
    # Capture SenderIP, SpamConfidenceLevel, and PolicyAction

    if [properties][SenderIP] != "" {
      mutate {
        replace => { "event.network.email.source.ip" => "%{[properties][SenderIP]}" }
        on_error => "zerror.REPLACE_sender_ip"
      }
    }

    if [properties][SpamConfidenceLevel] != "" {
      mutate {
        replace => { "event.security_result.confidence" => "%{[properties][SpamConfidenceLevel]}" }
        on_error => "zerror.REPLACE_spam_confidence"
      }
    }

    if [properties][PolicyAction] != "" {
      mutate {
        replace => { "event.security_result.action" => "%{[properties][PolicyAction]}" }
        on_error => "zerror.REPLACE_policy_action"
      }
    }

  } # end Publish


  # -----------------------------
  # 3) GENERIC (OUTSIDE Publish)
  # -----------------------------
  if [properties][AppVersion] != "" {
    mutate {
      convert  => { "properties.AppVersion" : "string" } on_error => "zerror.AppVersion_already_string"
    }
    mutate {
      replace  => { "event.target.platform_version" => "%{[properties][AppVersion]}" }
      on_error => "zerror.REPLACE_target_AppVersion"
    }
  }

  if [properties][SourceId] != "" {
    mutate {
      convert  => { "properties.SourceId" : "string" } on_error => "zerror.SourceId_already_string"
    }
    mutate {
      replace  => { "event.metadata.product_log_id" => "%{[properties][SourceId]}" }
      on_error => "zerror.REPLACE_sourceId"
    }
  }

  mutate {
    merge    => { "@output" : "event" }
    on_error => "zerror.MERGE_output"
  }
}
