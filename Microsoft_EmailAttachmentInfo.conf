# ====# ========================================================================
# Parser Name        : Microsoft_Email_Parser.conf
# Product            : Microsoft Security / Email
# Author             : rukky.soneye@foresite.com
# Last Updated       : 2025-10-30
# Notes              : UDM-only outputs (no idm.read_only_udm paths)
# ========================================================================

filter {

  # -----------------------------
  # 0) SAFE PRE-INIT
  # -----------------------------
  mutate {
    replace => {
      "sha_candidate" => ""
      "category"      => ""
      "operationName" => "%{operationName}"   # carry through if present
    }
  }

  # -----------------------------
  # 1) EXTRACT JSON
  # -----------------------------
  json {
    source         => "message"
    array_function => "split_columns"
    on_error       => "zerror.json_data_invalid"
  }

  # Normalize product_event_type early (prefer properties.OperationName)
  if [properties][OperationName] != "" {
    mutate { replace => { "operationName" => "%{[properties][OperationName]}" } }
  }

  # -----------------------------
  # 2) HANDLE ONLY EMAIL "Publish" EVENTS
  # -----------------------------
  if [operationName] == "Publish" {

    # ---- UDM: metadata.product_event_type
    if [operationName] != "" {
      mutate {
        replace  => { "event.metadata.product_event_type" => "%{operationName}" }
        on_error => "zerror.REPLACE_product_event_type"
      }
    }

    # ---- UDM: target.administrative_domain
    if [properties][RecipientDomain] != "" {
      mutate {
        replace  => { "event.target.administrative_domain" => "%{[properties][RecipientDomain]}" }
        on_error => "zerror.REPLACE_target_administrative_domain"
      }
    }

    # ---- UDM: security_result (prefer free-text in category_details)
    if [properties][ThreatClassification] != "" {
      mutate {
        replace  => { "event.security_result.category_details" => "%{[properties][ThreatClassification]}" }
        on_error => "zerror.REPLACE_threat_category_details"
      }
    }

    # -----------------------------
    # 2a) EMAIL RECIPIENTS (TO / CC)
    # -----------------------------
    # We’ll build temporary arrays to_list and cc_list, then merge.

    # Initialize scratch arrays (safe no-ops if they don’t exist)
    mutate { add_fields => { "to_list" => [] "cc_list" => [] } }

    # ---- TO: could be array of strings, array of objects with .Address, or a delimited string
    if [properties][To] != "" {
      # Case A: iterate raw elements; for each, try to match an email
      for item in properties.To {
        # Try direct string
        grok {
          match    => { "item" : [ "%{EMAILADDRESS:__to_email}" ] }
          on_error => "ignore_to_string"
        }
        if [__to_email] != "" {
          mutate { append => { "to_list" => "%{__to_email}" } }
          mutate { remove_field => ["__to_email"] }
        } else {
          # Try object.Address
          grok {
            match    => { "[item][Address]" : [ "%{EMAILADDRESS:__to_email2}" ] }
            on_error => "ignore_to_obj"
          }
          if [__to_email2] != "" {
            mutate { append => { "to_list" => "%{__to_email2}" } }
            mutate { remove_field => ["__to_email2"] }
          }
        }
      }
    }

    # ---- CC: same handling
    if [properties][Cc] != "" {
      for item in properties.Cc {
        grok {
          match    => { "item" : [ "%{EMAILADDRESS:__cc_email}" ] }
          on_error => "ignore_cc_string"
        }
        if [__cc_email] != "" {
          mutate { append => { "cc_list" => "%{__cc_email}" } }
          mutate { remove_field => ["__cc_email"] }
        } else {
          grok {
            match    => { "[item][Address]" : [ "%{EMAILADDRESS:__cc_email2}" ] }
            on_error => "ignore_cc_obj"
          }
          if [__cc_email2] != "" {
            mutate { append => { "cc_list" => "%{__cc_email2}" } }
            mutate { remove_field => ["__cc_email2"] }
          }
        }
      }
    }

    # ---- UDM email arrays
    if [to_list] {
      mutate { replace => { "event.network.email.to" => "%{to_list}" } }
    }
    if [cc_list] {
      mutate { replace => { "event.network.email.cc" => "%{cc_list}" } }
    }

    # -----------------------------
    # 2b) SHA256 with fallbacks
    # -----------------------------
    mutate { replace => { "sha_candidate" => "" } }

    # Primary
    if [properties][SHA256] != "" {
      mutate { replace => { "sha_candidate" => "%{[properties][SHA256]}" } on_error => "zerror.sha_try1_missing" }
    }

    # Fallbacks
    if [sha_candidate] == "" and [properties][FileSha256] != "" {
      mutate { replace => { "sha_candidate" => "%{[properties][FileSha256]}" } on_error => "zerror.sha_try2_missing" }
    }
    if [sha_candidate] == "" and [properties][AttachmentSha256] != "" {
      mutate { replace => { "sha_candidate" => "%{[properties][AttachmentSha256]}" } on_error => "zerror.sha_try3_missing" }
    }
    # Unusual key with space
    if [sha_candidate] == "" and [properties]["FileSha 256"] != "" {
      mutate { replace => { "sha_candidate" => "%{[properties][FileSha 256]}" } on_error => "zerror.sha_try4_missing" }
    }

    if [sha_candidate] != "" {
      mutate {
        replace  => { "event.target.file.sha256" => "%{sha_candidate}" }
        on_error => "zerror.REPLACE_target_file_sha256"
      }
    }

    # -----------------------------
    # 2c) FIELDS WITHOUT DIRECT UDM → additional.fields[]
    # -----------------------------
    # Helper macro style: coerce to string when likely non-string

    # DistributionList
    if [properties][DistributionList] != "" {
      mutate { replace => { "x_kv.key" => "DistributionList" "x_kv.value.string_value" => "%{[properties][DistributionList]}" } }
      mutate { merge  => { "event.additional.fields" => "x_kv" } }
    }

    # ForwardingInformation
    if [properties][ForwardingInformation] != "" {
      mutate { replace => { "x_kv.key" => "ForwardingInformation" "x_kv.value.string_value" => "%{[properties][ForwardingInformation]}" } }
      mutate { merge  => { "event.additional.fields" => "x_kv" } }
    }

    # Context
    if [properties][Context] != "" {
      mutate { replace => { "x_kv.key" => "Context" "x_kv.value.string_value" => "%{[properties][Context]}" } }
      mutate { merge  => { "event.additional.fields" => "x_kv" } }
    }

    # EmailSize (ensure string)
    if [properties][EmailSize] != "" {
      mutate { convert => { "properties.EmailSize" : "string" } on_error => "zerror.EmailSize_already_string" }
      mutate { replace => { "x_kv.key" => "EmailSize" "x_kv.value.string_value" => "%{[properties][EmailSize]}" } }
      mutate { merge  => { "event.additional.fields" => "x_kv" } }
    }

    # IsFirstContact (ensure string)
    if [properties][IsFirstContact] != "" {
      mutate { convert => { "properties.IsFirstContact" : "string" } on_error => "zerror.IsFirstContact_already_string" }
      mutate { replace => { "x_kv.key" => "IsFirstContact" "x_kv.value.string_value" => "%{[properties][IsFirstContact]}" } }
      mutate { merge  => { "event.additional.fields" => "x_kv" } }
    }

    # FileExtension (ensure string)
    if [properties][FileExtension] != "" {
      mutate { convert => { "properties.FileExtension" : "string" } on_error => "zerror.FileExtension_already_string" }
      mutate { replace => { "x_kv.key" => "FileExtension" "x_kv.value.string_value" => "%{[properties][FileExtension]}" } }
      mutate { merge  => { "event.additional.fields" => "x_kv" } }
    }

  }  # end Publish

  # -----------------------------
  # 3) GENERIC (OUTSIDE Publish)
  # -----------------------------

  # target.platform_version from AppVersion
  if [properties][AppVersion] != "" {
    mutate {
      convert  => { "properties.AppVersion" : "string" } on_error => "zerror.AppVersion_already_string"
    }
    mutate {
      replace  => { "event.target.platform_version" => "%{[properties][AppVersion]}" }
      on_error => "zerror.REPLACE_target_AppVersion"
    }
  }

  # metadata.product_log_id from SourceId
  if [properties][SourceId] != "" {
    mutate {
      convert  => { "properties.SourceId" : "string" } on_error => "zerror.SourceId_already_string"
    }
    mutate {
      replace  => { "event.metadata.product_log_id" => "%{[properties][SourceId]}" }
      on_error => "zerror.REPLACE_sourceId"
    }
  }

  # Final output (merge all built UDM into @output)
  mutate {
    merge    => { "@output" : "event" }
    on_error => "zerror.MERGE_output"
  }
}# ========================================================================
# Parser Name        : Microsoft_Email_Parser.conf
# Product            : Microsoft Security / Email
# Author             : rukky.soneye@foresite.com
# Last Updated       : 2025-10-30
# Notes              : UDM-only outputs (no idm.read_only_udm paths)
# ========================================================================

filter {

  # -----------------------------
  # 0) SAFE PRE-INIT
  # -----------------------------
  mutate {
    replace => {
      "sha_candidate" => ""
      "category"      => ""
      "operationName" => "%{operationName}"   # carry through if present
    }
  }

  # -----------------------------
  # 1) EXTRACT JSON
  # -----------------------------
  json {
    source         => "message"
    array_function => "split_columns"
    on_error       => "zerror.json_data_invalid"
  }

  # Normalize product_event_type early (prefer properties.OperationName)
  if [properties][OperationName] != "" {
    mutate { replace => { "operationName" => "%{[properties][OperationName]}" } }
  }

  # -----------------------------
  # 2) HANDLE ONLY EMAIL "Publish" EVENTS
  # -----------------------------
  if [operationName] == "Publish" {

    # ---- UDM: metadata.product_event_type
    if [operationName] != "" {
      mutate {
        replace  => { "event.metadata.product_event_type" => "%{operationName}" }
        on_error => "zerror.REPLACE_product_event_type"
      }
    }

    # ---- UDM: target.administrative_domain
    if [properties][RecipientDomain] != "" {
      mutate {
        replace  => { "event.target.administrative_domain" => "%{[properties][RecipientDomain]}" }
        on_error => "zerror.REPLACE_target_administrative_domain"
      }
    }

    # ---- UDM: security_result (prefer free-text in category_details)
    if [properties][ThreatClassification] != "" {
      mutate {
        replace  => { "event.security_result.category_details" => "%{[properties][ThreatClassification]}" }
        on_error => "zerror.REPLACE_threat_category_details"
      }
    }

    # -----------------------------
    # 2a) EMAIL RECIPIENTS (TO / CC)
    # -----------------------------
    # We’ll build temporary arrays to_list and cc_list, then merge.

    # Initialize scratch arrays (safe no-ops if they don’t exist)
    mutate { add_fields => { "to_list" => [] "cc_list" => [] } }

    # ---- TO: could be array of strings, array of objects with .Address, or a delimited string
    if [properties][To] != "" {
      # Case A: iterate raw elements; for each, try to match an email
      for item in properties.To {
        # Try direct string
        grok {
          match    => { "item" : [ "%{EMAILADDRESS:__to_email}" ] }
          on_error => "ignore_to_string"
        }
        if [__to_email] != "" {
          mutate { append => { "to_list" => "%{__to_email}" } }
          mutate { remove_field => ["__to_email"] }
        } else {
          # Try object.Address
          grok {
            match    => { "[item][Address]" : [ "%{EMAILADDRESS:__to_email2}" ] }
            on_error => "ignore_to_obj"
          }
          if [__to_email2] != "" {
            mutate { append => { "to_list" => "%{__to_email2}" } }
            mutate { remove_field => ["__to_email2"] }
          }
        }
      }
    }

    # ---- CC: same handling
    if [properties][Cc] != "" {
      for item in properties.Cc {
        grok {
          match    => { "item" : [ "%{EMAILADDRESS:__cc_email}" ] }
          on_error => "ignore_cc_string"
        }
        if [__cc_email] != "" {
          mutate { append => { "cc_list" => "%{__cc_email}" } }
          mutate { remove_field => ["__cc_email"] }
        } else {
          grok {
            match    => { "[item][Address]" : [ "%{EMAILADDRESS:__cc_email2}" ] }
            on_error => "ignore_cc_obj"
          }
          if [__cc_email2] != "" {
            mutate { append => { "cc_list" => "%{__cc_email2}" } }
            mutate { remove_field => ["__cc_email2"] }
          }
        }
      }
    }

    # ---- UDM email arrays
    if [to_list] {
      mutate { replace => { "event.network.email.to" => "%{to_list}" } }
    }
    if [cc_list] {
      mutate { replace => { "event.network.email.cc" => "%{cc_list}" } }
    }

    # -----------------------------
    # 2b) SHA256 with fallbacks
    # -----------------------------
    mutate { replace => { "sha_candidate" => "" } }

    # Primary
    if [properties][SHA256] != "" {
      mutate { replace => { "sha_candidate" => "%{[properties][SHA256]}" } on_error => "zerror.sha_try1_missing" }
    }

    # Fallbacks
    if [sha_candidate] == "" and [properties][FileSha256] != "" {
      mutate { replace => { "sha_candidate" => "%{[properties][FileSha256]}" } on_error => "zerror.sha_try2_missing" }
    }
    if [sha_candidate] == "" and [properties][AttachmentSha256] != "" {
      mutate { replace => { "sha_candidate" => "%{[properties][AttachmentSha256]}" } on_error => "zerror.sha_try3_missing" }
    }
    # Unusual key with space
    if [sha_candidate] == "" and [properties]["FileSha 256"] != "" {
      mutate { replace => { "sha_candidate" => "%{[properties][FileSha 256]}" } on_error => "zerror.sha_try4_missing" }
    }

    if [sha_candidate] != "" {
      mutate {
        replace  => { "event.target.file.sha256" => "%{sha_candidate}" }
        on_error => "zerror.REPLACE_target_file_sha256"
      }
    }

    # -----------------------------
    # 2c) FIELDS WITHOUT DIRECT UDM → additional.fields[]
    # -----------------------------
    # Helper macro style: coerce to string when likely non-string

    # DistributionList
    if [properties][DistributionList] != "" {
      mutate { replace => { "x_kv.key" => "DistributionList" "x_kv.value.string_value" => "%{[properties][DistributionList]}" } }
      mutate { merge  => { "event.additional.fields" => "x_kv" } }
    }

    # ForwardingInformation
    if [properties][ForwardingInformation] != "" {
      mutate { replace => { "x_kv.key" => "ForwardingInformation" "x_kv.value.string_value" => "%{[properties][ForwardingInformation]}" } }
      mutate { merge  => { "event.additional.fields" => "x_kv" } }
    }

    # Context
    if [properties][Context] != "" {
      mutate { replace => { "x_kv.key" => "Context" "x_kv.value.string_value" => "%{[properties][Context]}" } }
      mutate { merge  => { "event.additional.fields" => "x_kv" } }
    }

    # EmailSize (ensure string)
    if [properties][EmailSize] != "" {
      mutate { convert => { "properties.EmailSize" : "string" } on_error => "zerror.EmailSize_already_string" }
      mutate { replace => { "x_kv.key" => "EmailSize" "x_kv.value.string_value" => "%{[properties][EmailSize]}" } }
      mutate { merge  => { "event.additional.fields" => "x_kv" } }
    }

    # IsFirstContact (ensure string)
    if [properties][IsFirstContact] != "" {
      mutate { convert => { "properties.IsFirstContact" : "string" } on_error => "zerror.IsFirstContact_already_string" }
      mutate { replace => { "x_kv.key" => "IsFirstContact" "x_kv.value.string_value" => "%{[properties][IsFirstContact]}" } }
      mutate { merge  => { "event.additional.fields" => "x_kv" } }
    }

    # FileExtension (ensure string)
    if [properties][FileExtension] != "" {
      mutate { convert => { "properties.FileExtension" : "string" } on_error => "zerror.FileExtension_already_string" }
      mutate { replace => { "x_kv.key" => "FileExtension" "x_kv.value.string_value" => "%{[properties][FileExtension]}" } }
      mutate { merge  => { "event.additional.fields" => "x_kv" } }
    }

  }  # end Publish

  # -----------------------------
  # 3) GENERIC (OUTSIDE Publish)
  # -----------------------------

  # target.platform_version from AppVersion
  if [properties][AppVersion] != "" {
    mutate {
      convert  => { "properties.AppVersion" : "string" } on_error => "zerror.AppVersion_already_string"
    }
    mutate {
      replace  => { "event.target.platform_version" => "%{[properties][AppVersion]}" }
      on_error => "zerror.REPLACE_target_AppVersion"
    }
  }

  # metadata.product_log_id from SourceId
  if [properties][SourceId] != "" {
    mutate {
      convert  => { "properties.SourceId" : "string" } on_error => "zerror.SourceId_already_string"
    }
    mutate {
      replace  => { "event.metadata.product_log_id" => "%{[properties][SourceId]}" }
      on_error => "zerror.REPLACE_sourceId"
    }
  }

  # Final output (merge all built UDM into @output)
  mutate {
    merge    => { "@output" : "event" }
    on_error => "zerror.MERGE_output"
  }
}====================================================================
# Parser Name        : Microsoft_Email_Parser.conf
# Product            : Microsoft Security / Email
# Author             : rukky.soneye@foresite.com
# Last Updated       : 2025-10-30
# Notes              : UDM-only outputs (no idm.read_only_udm paths)
# ========================================================================

filter {

  # -----------------------------
  # 0) SAFE PRE-INIT
  # -----------------------------
  mutate {
    replace => {
      "sha_candidate" => ""
      "category"      => ""
      "operationName" => "%{operationName}"   # carry through if present
    }
  }

  # -----------------------------
  # 1) EXTRACT JSON
  # -----------------------------
  json {
    source         => "message"
    array_function => "split_columns"
    on_error       => "zerror.json_data_invalid"
  }

  # Normalize product_event_type early (prefer properties.OperationName)
  if [properties][OperationName] != "" {
    mutate { replace => { "operationName" => "%{[properties][OperationName]}" } }
  }

  # -----------------------------
  # 2) HANDLE ONLY EMAIL "Publish" EVENTS
  # -----------------------------
  if [operationName] == "Publish" {

    # ---- UDM: metadata.product_event_type
    if [operationName] != "" {
      mutate {
        replace  => { "event.metadata.product_event_type" => "%{operationName}" }
        on_error => "zerror.REPLACE_product_event_type"
      }
    }

    # ---- UDM: target.administrative_domain
    if [properties][RecipientDomain] != "" {
      mutate {
        replace  => { "event.target.administrative_domain" => "%{[properties][RecipientDomain]}" }
        on_error => "zerror.REPLACE_target_administrative_domain"
      }
    }

    # ---- UDM: security_result (prefer free-text in category_details)
    if [properties][ThreatClassification] != "" {
      mutate {
        replace  => { "event.security_result.category_details" => "%{[properties][ThreatClassification]}" }
        on_error => "zerror.REPLACE_threat_category_details"
      }
    }

    # -----------------------------
    # 2a) EMAIL RECIPIENTS (TO / CC)
    # -----------------------------
    # We’ll build temporary arrays to_list and cc_list, then merge.

    # Initialize scratch arrays (safe no-ops if they don’t exist)
    mutate { add_fields => { "to_list" => [] "cc_list" => [] } }

    # ---- TO: could be array of strings, array of objects with .Address, or a delimited string
    if [properties][To] != "" {
      # Case A: iterate raw elements; for each, try to match an email
      for item in properties.To {
        # Try direct string
        grok {
          match    => { "item" : [ "%{EMAILADDRESS:__to_email}" ] }
          on_error => "ignore_to_string"
        }
        if [__to_email] != "" {
          mutate { append => { "to_list" => "%{__to_email}" } }
          mutate { remove_field => ["__to_email"] }
        } else {
          # Try object.Address
          grok {
            match    => { "[item][Address]" : [ "%{EMAILADDRESS:__to_email2}" ] }
            on_error => "ignore_to_obj"
          }
          if [__to_email2] != "" {
            mutate { append => { "to_list" => "%{__to_email2}" } }
            mutate { remove_field => ["__to_email2"] }
          }
        }
      }
    }

    # ---- CC: same handling
    if [properties][Cc] != "" {
      for item in properties.Cc {
        grok {
          match    => { "item" : [ "%{EMAILADDRESS:__cc_email}" ] }
          on_error => "ignore_cc_string"
        }
        if [__cc_email] != "" {
          mutate { append => { "cc_list" => "%{__cc_email}" } }
          mutate { remove_field => ["__cc_email"] }
        } else {
          grok {
            match    => { "[item][Address]" : [ "%{EMAILADDRESS:__cc_email2}" ] }
            on_error => "ignore_cc_obj"
          }
          if [__cc_email2] != "" {
            mutate { append => { "cc_list" => "%{__cc_email2}" } }
            mutate { remove_field => ["__cc_email2"] }
          }
        }
      }
    }

    # ---- UDM email arrays
    if [to_list] {
      mutate { replace => { "event.network.email.to" => "%{to_list}" } }
    }
    if [cc_list] {
      mutate { replace => { "event.network.email.cc" => "%{cc_list}" } }
    }

    # -----------------------------
    # 2b) SHA256 with fallbacks
    # -----------------------------
    mutate { replace => { "sha_candidate" => "" } }

    # Primary
    if [properties][SHA256] != "" {
      mutate { replace => { "sha_candidate" => "%{[properties][SHA256]}" } on_error => "zerror.sha_try1_missing" }
    }

    # Fallbacks
    if [sha_candidate] == "" and [properties][FileSha256] != "" {
      mutate { replace => { "sha_candidate" => "%{[properties][FileSha256]}" } on_error => "zerror.sha_try2_missing" }
    }
    if [sha_candidate] == "" and [properties][AttachmentSha256] != "" {
      mutate { replace => { "sha_candidate" => "%{[properties][AttachmentSha256]}" } on_error => "zerror.sha_try3_missing" }
    }
    # Unusual key with space
    if [sha_candidate] == "" and [properties]["FileSha 256"] != "" {
      mutate { replace => { "sha_candidate" => "%{[properties][FileSha 256]}" } on_error => "zerror.sha_try4_missing" }
    }

    if [sha_candidate] != "" {
      mutate {
        replace  => { "event.target.file.sha256" => "%{sha_candidate}" }
        on_error => "zerror.REPLACE_target_file_sha256"
      }
    }

    # -----------------------------
    # 2c) FIELDS WITHOUT DIRECT UDM → additional.fields[]
    # -----------------------------
    # Helper macro style: coerce to string when likely non-string

    # DistributionList
    if [properties][DistributionList] != "" {
      mutate { replace => { "x_kv.key" => "DistributionList" "x_kv.value.string_value" => "%{[properties][DistributionList]}" } }
      mutate { merge  => { "event.additional.fields" => "x_kv" } }
    }

    # ForwardingInformation
    if [properties][ForwardingInformation] != "" {
      mutate { replace => { "x_kv.key" => "ForwardingInformation" "x_kv.value.string_value" => "%{[properties][ForwardingInformation]}" } }
      mutate { merge  => { "event.additional.fields" => "x_kv" } }
    }

    # Context
    if [properties][Context] != "" {
      mutate { replace => { "x_kv.key" => "Context" "x_kv.value.string_value" => "%{[properties][Context]}" } }
      mutate { merge  => { "event.additional.fields" => "x_kv" } }
    }

    # EmailSize (ensure string)
    if [properties][EmailSize] != "" {
      mutate { convert => { "properties.EmailSize" : "string" } on_error => "zerror.EmailSize_already_string" }
      mutate { replace => { "x_kv.key" => "EmailSize" "x_kv.value.string_value" => "%{[properties][EmailSize]}" } }
      mutate { merge  => { "event.additional.fields" => "x_kv" } }
    }

    # IsFirstContact (ensure string)
    if [properties][IsFirstContact] != "" {
      mutate { convert => { "properties.IsFirstContact" : "string" } on_error => "zerror.IsFirstContact_already_string" }
      mutate { replace => { "x_kv.key" => "IsFirstContact" "x_kv.value.string_value" => "%{[properties][IsFirstContact]}" } }
      mutate { merge  => { "event.additional.fields" => "x_kv" } }
    }

    # FileExtension (ensure string)
    if [properties][FileExtension] != "" {
      mutate { convert => { "properties.FileExtension" : "string" } on_error => "zerror.FileExtension_already_string" }
      mutate { replace => { "x_kv.key" => "FileExtension" "x_kv.value.string_value" => "%{[properties][FileExtension]}" } }
      mutate { merge  => { "event.additional.fields" => "x_kv" } }
    }

  }  # end Publish

  # -----------------------------
  # 3) GENERIC (OUTSIDE Publish)
  # -----------------------------

  # target.platform_version from AppVersion
  if [properties][AppVersion] != "" {
    mutate {
      convert  => { "properties.AppVersion" : "string" } on_error => "zerror.AppVersion_already_string"
    }
    mutate {
      replace  => { "event.target.platform_version" => "%{[properties][AppVersion]}" }
      on_error => "zerror.REPLACE_target_AppVersion"
    }
  }

  # metadata.product_log_id from SourceId
  if [properties][SourceId] != "" {
    mutate {
      convert  => { "properties.SourceId" : "string" } on_error => "zerror.SourceId_already_string"
    }
    mutate {
      replace  => { "event.metadata.product_log_id" => "%{[properties][SourceId]}" }
      on_error => "zerror.REPLACE_sourceId"
    }
  }

  # Final output (merge all built UDM into @output)
  mutate {
    merge    => { "@output" : "event" }
    on_error => "zerror.MERGE_output"
  }
}
